<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>é›¶ç”¨é‡‘æŸ¥è©¢</title>
  <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    h3 { text-align:center; font-size: 24px; margin-bottom: 10px; }
    .date-inputs { text-align:center; margin-bottom: 12px; }
    .date-inputs input { margin: 0 6px; padding:6px; font-size:14px; }
    .buttons { text-align:center; margin-bottom: 14px; }
    button { font-size:16px; padding:8px 14px; margin:6px; border-radius:6px; cursor:pointer; }
    #queryResult { margin-top: 12px; }
    table { border-collapse: collapse; width:100%; margin-top:10px; font-size:14px; }
    th, td { border:1px solid #ddd; padding:8px; text-align:center; }
    th { background:#f2f2f2; user-select:none; }
    th.sort-asc::after { content:" â–²"; }
    th.sort-desc::after { content:" â–¼"; }
    .numeric { text-align:right; }
    .total { margin-top:10px; font-weight:bold; color:#d9534f; }
    canvas { display:block; margin:18px auto; max-width:900px; }
  </style>
</head>
<body>

<h3>éçœ‹ä¸å¯. [<span id="version"></span>]</h3>

<div class="date-inputs">
  é–‹å§‹æ—¥æœŸï¼š<input type="date" id="startDate">
  çµæŸæ—¥æœŸï¼š<input type="date" id="endDate">
</div>

<div class="buttons">
  <button id="queryDetailBtn">ğŸ“Š æŸ¥è©¢æ˜ç´°</button>
  <button id="queryPayBtn">ğŸ’³ æŸ¥è©¢ä»˜æ¬¾</button>
  <button id="queryCatBtn">â­• æŸ¥è©¢åˆ†é¡</button>
  <button id="queryStoreBtn">ğŸ“‹ æŸ¥è©¢åº—å®¶</button>
</div>

<div id="queryResult"></div>
<canvas id="chartCanvas"></canvas>

<script>
const LIFF_ID = "2008096451-jPJ50MOY";
const VERSION = "T9";
const API_URL = "https://script.google.com/macros/s/AKfycbwQ1t5wHfjAqrtH0_ijNNWtlE5Q0R-g8fwb5htWQoCXKXxSukVX9qVnrfuyoXOyKkGXdw/exec"; // <- æ›æˆä½ çš„ GAS

let chartInstance = null;
document.getElementById("version").textContent = VERSION;

// init liff + default dates
async function main(){
  try{
    await liff.init({ liffId: LIFF_ID });
    if (!liff.isLoggedIn()) liff.login();
  }catch(e){
    // è‹¥ LIFF åˆå§‹åŒ–å¤±æ•—ä¹Ÿä¸è¦é˜»æ–·åŠŸèƒ½ï¼ˆæ–¹ä¾¿æ¸¬è©¦ï¼‰
    console.warn("LIFF init failed:", e);
  }
  setDefaultDateRange();
}
main();

function setDefaultDateRange(){
  const now = new Date();
  const start = new Date(now.getFullYear(), now.getMonth(), 1);
  const end = new Date(now.getFullYear(), now.getMonth()+1, 0);
  document.getElementById("startDate").value = toInputDate(start);
  document.getElementById("endDate").value = toInputDate(end);
}
function toInputDate(d){
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  return `${d.getFullYear()}-${mm}-${dd}`;
}

// ç¶å®šæŒ‰éˆ•
document.getElementById("queryDetailBtn").addEventListener("click", () => sendQuery("æ˜ç´°"));
document.getElementById("queryPayBtn").addEventListener("click", () => sendQuery("ä»˜æ¬¾"));
document.getElementById("queryCatBtn").addEventListener("click", () => sendQuery("åˆ†é¡"));
document.getElementById("queryStoreBtn").addEventListener("click", () => sendQuery("åº—å®¶"));

// ---------- è¼”åŠ©ï¼šè§£æ cell æ–‡å­—æˆå¯æ¯”è¼ƒå€¼ ----------
function parseDateString(str){
  if (!str) return null;
  str = str.trim();
  // å¸¸è¦‹æ ¼å¼ï¼šYYYY-MM-DD æˆ– YYYY/MM/DD
  let m = str.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/);
  if (m) return new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]));
  // M/D/YYYY or M/D/YY
  m = str.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
  if (m) return new Date(Number(m[3]), Number(m[1]) - 1, Number(m[2]));
  // try Date.parse fallback
  const t = Date.parse(str);
  if (!isNaN(t)) return new Date(t);
  return null;
}

function parseCellValue(text){
  if (text === null || text === undefined) return { type:'string', value: '' };
  let s = String(text).trim();
  if (s === '') return { type:'string', value: '' };

  // ç™¾åˆ†æ¯” e.g. "12.3%"
  const pct = s.match(/^(-?[\d,]+(?:\.\d+)?)\s*%$/);
  if (pct) return { type:'number', value: parseFloat(pct[1].replace(/,/g,'')) };

  // æ•¸å­—ï¼ˆå«åƒåˆ†ä½ commaï¼‰
  const num = s.match(/^(-?[\d,]+(?:\.\d+)?)$/);
  if (num) return { type:'number', value: parseFloat(num[1].replace(/,/g,'')) };

  // å˜—è©¦è§£ææ—¥æœŸ
  const d = parseDateString(s);
  if (d) return { type:'date', value: d.getTime() };

  // æ–‡å­—ï¼ˆä¸­æ–‡/è‹±æ–‡ï¼‰ - ä¿ç•™åŸå§‹å­—ä¸²
  return { type:'string', value: s };
}

// ---------- å¯æ’åºè¡¨æ ¼å‡½å¼ ----------
function makeTableSortable(table){
  const headers = Array.from(table.querySelectorAll("th"));
  headers.forEach((th, colIndex) => {
    th.style.cursor = "pointer";
    // initialize dataset.order to none
    if (!th.dataset.order) th.dataset.order = "none";

    th.addEventListener("click", () => {
      const tbody = table.tBodies && table.tBodies[0] ? table.tBodies[0] : table;
      const rows = Array.from(tbody.querySelectorAll("tr")).slice(1); // skip header row

      // Detect column type by scanning first non-empty cell
      let detected = null;
      for (const r of rows){
        const cellText = (r.cells[colIndex] && r.cells[colIndex].textContent) ? r.cells[colIndex].textContent.trim() : "";
        if (cellText !== ""){
          detected = parseCellValue(cellText);
          break;
        }
      }
      // default to string
      const colType = detected ? detected.type : "string";

      // clear indicators on all headers
      headers.forEach(h => { h.classList.remove("sort-asc","sort-desc"); h.dataset.order = "none"; });

      // toggle order
      const current = th.dataset.order === "asc" ? "asc" : (th.dataset.order === "desc" ? "desc" : null);
      const order = current === "asc" ? "desc" : "asc";
      th.dataset.order = order;
      th.classList.add(order === "asc" ? "sort-asc" : "sort-desc");

      rows.sort((ra, rb) => {
        const aRaw = (ra.cells[colIndex] && ra.cells[colIndex].textContent) ? ra.cells[colIndex].textContent.trim() : "";
        const bRaw = (rb.cells[colIndex] && rb.cells[colIndex].textContent) ? rb.cells[colIndex].textContent.trim() : "";

        const a = parseCellValue(aRaw);
        const b = parseCellValue(bRaw);

        let cmp = 0;
        if (colType === 'number' || a.type === 'number' || b.type === 'number'){
          const va = (a.type === 'number') ? a.value : (parseCellValue(aRaw).type === 'number' ? parseCellValue(aRaw).value : 0);
          const vb = (b.type === 'number') ? b.value : (parseCellValue(bRaw).type === 'number' ? parseCellValue(bRaw).value : 0);
          cmp = va - vb;
        } else if (colType === 'date' || a.type === 'date' || b.type === 'date'){
          const va = (a.type === 'date') ? a.value : (parseCellValue(aRaw).type === 'date' ? parseCellValue(aRaw).value : 0);
          const vb = (b.type === 'date') ? b.value : (parseCellValue(bRaw).type === 'date' ? parseCellValue(bRaw).value : 0);
          cmp = va - vb;
        } else {
          // string compare with locale (handles Chinese + numeric parts)
          cmp = String(a.value).localeCompare(String(b.value), 'zh-Hant-TW', { numeric: true, sensitivity: 'base' });
        }

        return (order === 'asc') ? cmp : -cmp;
      });

      // re-append rows in sorted order
      rows.forEach(r => tbody.appendChild(r));
    });
  });
}

// ---------- æŸ¥è©¢èˆ‡ render ----------
async function sendQuery(command){
  const s = document.getElementById("startDate").value;
  const e = document.getElementById("endDate").value;
  if (!s || !e){ alert("è«‹å…ˆé¸æ“‡èµ·è¨–æ—¥æœŸ"); return; }

  const body = {
    type: "query",
    command: command,
    version: VERSION,
    startDate: s + (s.includes(" ") ? "" : " 00:00:00"),
    endDate: e + (e.includes(" ") ? "" : " 23:59:59")
  };

  try {
    const res = await fetch(API_URL, {
      method: "POST",
      body: JSON.stringify(body)
      // æ³¨æ„ï¼šä¸è¦é¡å¤–åŠ  Content-Type headerï¼ˆä½ ä¹‹å‰æåˆ°åŠ  header æœƒå‡ºç¾ Failed to fetchï¼‰
    });
    const json = await res.json();
    if (!json.ok) {
      document.getElementById("queryResult").innerHTML = `<p style="color:red">âŒ æŸ¥è©¢å¤±æ•—ï¼ˆä¼ºæœå™¨å›æ‡‰ï¼‰</p>`;
      return;
    }
    renderResult(command, json, s, e);
  } catch (err) {
    document.getElementById("queryResult").innerHTML = `<p style="color:red">âŒ æŸ¥è©¢å¤±æ•—ï¼š${err.message}</p>`;
  }
}

function renderResult(command, json, startDateText, endDateText){
  let html = `<div style="text-align:center; margin-bottom:6px;">ğŸ“… æŸ¥è©¢å€é–“ï¼š ${startDateText} ~ ${endDateText}</div>`;

  if (command === "æ˜ç´°" && json.rows){
    html += `<h4>ğŸ“Š æ˜ç´°</h4>`;
    html += `<table id="dataTable"><tr>
      <th>æ—¥æœŸ</th>
      <th>åº—å®¶</th>
      <th class="numeric">æ”¶å…¥</th>
      <th class="numeric">æ”¯å‡º</th>
      <th>å¹£åˆ¥</th>
      <th class="numeric">é‡‘é¡</th>
      <th>ä»˜æ¬¾</th>
      <th>åˆ†é¡</th>
      <th>é™„è¨»</th>
      <th>å‚™è¨»</th>
    </tr>`;
    json.rows.forEach(r => {
      const dateStr = r[4] ? new Date(r[4]).toLocaleDateString("zh-TW") : "";
      html += `<tr>
        <td>${dateStr}</td>
        <td>${escapeHtml(r[8]||"")}</td>
        <td class="numeric">${Number(r[11]||0).toLocaleString()}</td>
        <td class="numeric">${Number(r[12]||0).toLocaleString()}</td>
        <td>${escapeHtml(r[13]||"")}</td>
        <td class="numeric">${Number(r[5]||0).toLocaleString()}</td>
        <td>${escapeHtml(r[7]||"")}</td>
        <td>${escapeHtml(r[6]||"")}</td>
        <td>${escapeHtml(r[9]||"")}</td>
        <td>${escapeHtml(r[10]||"")}</td>
      </tr>`;
    });
    html += `</table>`;
    html += `<div class="total">ğŸ“Œ ç¸½é¡ï¼š${Number(json.total||0).toLocaleString()} å…ƒï¼ˆå…± ${json.rows.length} ç­†ï¼‰</div>`;

    // bar chart: æ—¥æœŸå½™ç¸½ï¼ˆæŠŠåŒä¸€å¤©åˆä½µï¼‰
    const dailyMap = {};
    json.rows.forEach(r => {
      const dObj = parseDateString(String(r[4]||"")) || new Date(String(r[4]||""));
      const key = dObj instanceof Date && !isNaN(dObj) ? `${dObj.getFullYear()}-${String(dObj.getMonth()+1).padStart(2,'0')}-${String(dObj.getDate()).padStart(2,'0')}` : String(r[4]||"");
      dailyMap[key] = (dailyMap[key] || 0) + (Number(r[5]) || 0);
    });
    // sort keys by date
    const dailyKeys = Object.keys(dailyMap).sort((a,b) => {
      const da = new Date(a); const db = new Date(b);
      return da - db;
    });
    const dailyLabels = dailyKeys.map(k => {
      const d = new Date(k);
      if (!isNaN(d)) return d.toLocaleDateString("zh-TW");
      return k;
    });
    const dailyValues = dailyKeys.map(k => dailyMap[k]);

    renderChart("bar", dailyLabels, dailyValues);
  }

  // åˆ†é¡
  if (command === "åˆ†é¡" && json.categories){
    const labels = Object.keys(json.categories);
    const values = labels.map(l => json.categories[l]);
    const total = values.reduce((a,b)=>a+b,0);
    html += `<h4>â­• åˆ†é¡çµ±è¨ˆ</h4>`;
    html += `<table id="dataTable"><tr><th>åˆ†é¡æ–¹å¼</th><th class="numeric">é‡‘é¡</th><th class="numeric">å æ¯”</th></tr>`;
    labels.forEach((lab,i) => {
      const v = values[i];
      const pct = total ? ((v/total)*100).toFixed(1) : "0.0";
      html += `<tr><td>${escapeHtml(lab)}</td><td class="numeric">${v.toLocaleString()}</td><td class="numeric">${pct}%</td></tr>`;
    });
    html += `</table>`;
    html += `<div class="total">ğŸ“Œ ç¸½é¡ï¼š${total.toLocaleString()} å…ƒï¼ˆå…± ${labels.length} ç¨®åˆ†é¡ï¼‰</div>`;
    renderChart("pie", labels, values);
  }

  // ä»˜æ¬¾
  if (command === "ä»˜æ¬¾" && json.payments){
    const labels = Object.keys(json.payments);
    const values = labels.map(l => json.payments[l]);
    const total = values.reduce((a,b)=>a+b,0);
    html += `<h4>ğŸ’³ ä»˜æ¬¾çµ±è¨ˆ</h4>`;
    html += `<table id="dataTable"><tr><th>ä»˜æ¬¾æ–¹å¼</th><th class="numeric">é‡‘é¡</th><th class="numeric">å æ¯”</th></tr>`;
    labels.forEach((lab,i) => {
      const v = values[i];
      const pct = total ? ((v/total)*100).toFixed(1) : "0.0";
      html += `<tr><td>${escapeHtml(lab)}</td><td class="numeric">${v.toLocaleString()}</td><td class="numeric">${pct}%</td></tr>`;
    });
    html += `</table>`;
    html += `<div class="total">ğŸ“Œ ç¸½é¡ï¼š${total.toLocaleString()} å…ƒï¼ˆå…± ${labels.length} ç¨®ä»˜æ¬¾ï¼‰</div>`;
    renderChart("pie", labels, values);
  }

  // åº—å®¶
  if (command === "åº—å®¶" && (json.stores || json.shops)){
    // some GAS versions return 'stores' or 'shops' â€” safe fallback
    const shopsObj = json.stores || json.shops || {};
    const labels = Object.keys(shopsObj);
    const values = labels.map(l => shopsObj[l]);
    const total = values.reduce((a,b)=>a+b,0);
    html += `<h4>ğŸ“‹ åº—å®¶çµ±è¨ˆ</h4>`;
    html += `<table id="dataTable"><tr><th>åº—å®¶</th><th class="numeric">é‡‘é¡</th><th class="numeric">å æ¯”</th></tr>`;
    labels.forEach((lab,i) => {
      const v = values[i];
      const pct = total ? ((v/total)*100).toFixed(1) : "0.0";
      html += `<tr><td>${escapeHtml(lab)}</td><td class="numeric">${v.toLocaleString()}</td><td class="numeric">${pct}%</td></tr>`;
    });
    html += `</table>`;
    html += `<div class="total">ğŸ“Œ ç¸½é¡ï¼š${total.toLocaleString()} å…ƒï¼ˆå…± ${labels.length} ç­†åº—å®¶ï¼‰</div>`;
    renderChart("pie", labels, values);
  }

  document.getElementById("queryResult").innerHTML = html;

  // attach sorting to newly created table (if exists)
  const tableEl = document.getElementById("dataTable");
  if (tableEl) makeTableSortable(tableEl);
}

// safe escape
function escapeHtml(s){ return String(s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

// ---------- åœ–è¡¨ ----------
// è‡ªå‹•ç”¢å¤šè‰²ï¼ˆpieï¼‰
function generateColors(n){
  const cols = [];
  for (let i=0;i<n;i++){
    const hue = Math.round((i * 360 / n) % 360);
    cols.push(`hsl(${hue},70%,60%)`);
  }
  return cols;
}

function renderChart(type, labels, values){
  const ctx = document.getElementById("chartCanvas").getContext("2d");
  if (chartInstance) chartInstance.destroy();
  const dataset = {
    labels,
    datasets: [{
      label: "é‡‘é¡",
      data: values,
      backgroundColor: (type === 'pie') ? generateColors(values.length) : "rgba(54,162,235,0.6)",
      borderColor: (type === 'pie') ? undefined : "rgba(54,162,235,1)",
      borderWidth: (type === 'pie') ? 0 : 1
    }]
  };
  const options = {
    responsive: true,
    plugins: { legend: { position: (type === 'pie' ? 'bottom' : 'top') } },
    scales: (type === 'bar') ? {
      x: { title: { display:true, text: 'æ—¥æœŸ' } },
      y: { title: { display:true, text: 'é‡‘é¡' }, beginAtZero:true }
    } : {}
  };
  chartInstance = new Chart(ctx, { type, data: dataset, options });
}
</script>

</body>
</html>
